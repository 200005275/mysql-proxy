/**
@mainpage

The MySQL Proxy is a simple program which sits between a mysql client and a mysql server and
can inspect, transform and act on the data sent through it.

You can use it for:
@li load balancing
@li fail over
@li query tracking
@li query analysis
@li ... and much more

It is built of different components that which are stacked and can be used independently:

@li @subpage page-chassis
  * commandline and configfiles
  * logging
  * daemon/service support
  * plugin loading
@li @subpage protocol
  * MySQL
    * client protocol
    * binlog protocol
    * myisam files
    * frm files
    * masterinfo files
@li @subpage page-core
  * connection life-cycle
@li @ref page-plugins 

@page page-chassis Chassis

@section section-chassisconfigfile Configfile and Commandline Options

GLib2 provides us with config-file parser and a command-line option parser. We want to expose 
most options in the same way and accept them from the config-file and the command-line.

The options are parsed in two steps:

@li extract the basic command-line options:
  \c --help
  \c --version
  \c --defaults-file
@li process the defaults-file 
@li process the other command-line options to override the defaults-file

@see src/chassis-keyfile.h and src/chassic.c

@section section-chassisplugin Plugin Interface

The chassis provides the fundamentals for the plugin interface:

@li it can resolve the path for plugins
@li can load them in a portable way
@li does version checks
@li calls init and shutdown functions 
@li exposes the configuration options to the plugins

@see src/chassis-plugin.h and struct chassis_plugin

As the chassis is not MySQL specific it can load any kind of plugin as long as it 
exposes the init and shutdown functions. 

For the MySQL Proxy you usually load plugins like:

@li @ref page-plugin-proxy
@li @ref page-plugin-admin

... which interface with MySQL @ref section-lifecycle. 

@page page-core Network Core

The Network core is built around the socket handling and brings a client and server connection
together. 

@see network_socket
@see network_mysqld_con

@section section-lifecycle Connection Life Cycle

Connections can be in one of several states which are basicly resembling the 4 basic phases
of the @ref protocol:

@li connect
@li authentification
@li query
@li disconnect

The plugins can change the default behaviour of the network core and impliment one of three 
basic plugins:

@li @ref page-plugin-admin implements only the listening side
@li client plugins implement only the connection side
@li @ref page-plugin-proxy implements both sides 

@subsection section-scripting Scripting

Most plugins implement a set of those callbacks and expose them to a scripting layer. 

For now the scriping is provided by Lua, a simple, fast and easy to embed scripting language.
We expose most of the internals into the scripting layer and provide modules to operate
on the data that we pass into the scripting layer

@section section-network-core-layer Network Core Layer

  The MySQL Proxy network engine is meant to handle several thousands connections at the same time. We 
want to use it for load-balancing and fail-over which means we have to handle the connections for
a larger group of MySQL backend servers nicely. We aim for 5k to 10k connections.
  Up to MySQL Proxy 0.7 we use a pure event-driven, non-blocking networking approach is described in
http://kegel.com/c10k.html#nb using libevent 1.4.x. 
  A event-driven design has a very small foot-print for idling connections: we just store the
connection state and let it wait for a event. 

@section section-threaded-io Threaded IO

  In MySQL 0.8 we added threaded network-io to allow the proxy to scale out with the numbers of CPUs 
and network cards available.

To enable network-threading you just start the proxy with:

@verbatim
  --event-threads={2 * no-of-cores} (default: 0)
@endverbatim

A event-thread is a simple small thread around "event_base_dispatch()" which on a network- or time-event
executes our core functions. These threads either execute the core functions or idle. If they idle 
they can read new events to wait for and add them to their wait-list.

A connection can jump between event-threads: the idling event-thread is taking the wait-for-event
request and executes the code. Whenever the connection has to wait for a event again it is unregister
itself from the thread, send its wait-for-event request to the global event-queue again.

  Up to MySQL Proxy 0.8 the execution of the scripting code is single-threaded: a global mutex protects
the plugin interface. As a connection is either sending packets or calling plugin function the network 
events will be handled in parallel and only wait if several connections want to call a plugin function

@subsection section-threaded-io-impl Implementation

In chassis-event-thread.c the chassis_event_thread_loop() is the event-thread itself. It gets setup by
chassis_event_threads_init_thread() which registers itself to a pipe(), a classic simple pipe. That
pipe is a common hack in libevent to map any kind of event to a the fd-based event-handlers like poll:

@li the @c event_base_dispatch() blocks until a fd-event triggers
@li timers, signals, ... can't interrupt @c event_base_dispatch() directly
@li instead they cause a @c write(pipe_fd, ".", 1); which triggers a fd-event
    which afterwards gets handled

In chassis-event-thread.c we use the pipe to signal that something is in the global event-queue to be
processed by one of the event-threads ... see chassis_event_handle(). All idling threads will process
that even and will pull from the event queue in parallel to add the event to their events to listen for.

To add a event to the event-queue you can call chassis_event_add() or chassis_event_add_local(). See 
the source when to use which.

@subsection section-threaded-scripting Threaded Scripting

Usually the scripts are small and only make simple decisions leaving most of the work to the network layer.
In 0.9 we will make the scripting layer multi-threaded allow several scripting threads at the same time,
working from a small pool threads.

That will allow the scripting layer to call blocking or slow functions without infecting the execution of
other connections.

Lifting the global plugin mutex will mean we have to handle access to global structure differently. Most 
of the access is happening on connection-level (the way we do the event-threading) and only access to
global structures like "proxy.global.*" has to synchronized. For that we will look into using Lua lanes
to send data around between independent Lua-states.



*/ 
